// 1. Create an API route to proxy images: /api/image-proxy/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const imageUrl = searchParams.get('url')
  
  if (!imageUrl) {
    return new NextResponse('Missing URL parameter', { status: 400 })
  }

  try {
    const response = await fetch(imageUrl)
    const imageBuffer = await response.arrayBuffer()
    
    return new NextResponse(imageBuffer, {
      headers: {
        'Content-Type': response.headers.get('Content-Type') || 'image/jpeg',
        'Cache-Control': 'public, max-age=31536000',
        'Access-Control-Allow-Origin': '*',
      },
    })
  } catch (error) {
    return new NextResponse('Failed to fetch image', { status: 500 })
  }
}

// 2. Update your addImageToCanvas function:
const addImageToCanvas = useCallback((imageUrl: string, replaceObjects?: any) => {
  if (!fabricCanvasRef.current) return

  const canvas = fabricCanvasRef.current
  
  // Proxy external images through your API
  const proxiedUrl = imageUrl.startsWith('http') && !imageUrl.includes(window.location.hostname)
    ? `/api/image-proxy?url=${encodeURIComponent(imageUrl)}`
    : imageUrl

  const imgElement = new Image()
  imgElement.crossOrigin = "anonymous" // This now works because it's same-origin
  
  imgElement.onload = () => {
    import("fabric").then((FabricModule) => {
      const fabric = FabricModule
      
      let left = (canvas.width - imgElement.width) / 2
      let top = (canvas.height - imgElement.height) / 2
      
      if (replaceObjects?.placeholder) {
        left = replaceObjects.placeholder.left
        top = replaceObjects.placeholder.top
      }
      
      const fabricImage = new fabric.Image(imgElement, { left, top })
      
      const maxWidth = 400
      const maxHeight = 400
      const scale = Math.min(maxWidth / fabricImage.width, maxHeight / fabricImage.height, 1)
      
      fabricImage.set({ scaleX: scale, scaleY: scale })
      
      if (replaceObjects) {
        if (replaceObjects.placeholder) canvas.remove(replaceObjects.placeholder)
        if (replaceObjects.text) canvas.remove(replaceObjects.text)
      }
      
      canvas.add(fabricImage)
      canvas.setActiveObject(fabricImage)
      canvas.renderAll()
      handleCanvasChange()
    })
  }
  
  imgElement.src = proxiedUrl
}, [])

// 3. Now your thumbnail generation works:
const saveCanvasState = async (immediate = false) => {
  if (!fabricCanvasRef.current || !document || canvasState.isSaving) return

  try {
    setIsSaving(true)
    const canvasData = fabricCanvasRef.current.toJSON()

    // This now works because all images are same-origin!
    const thumbnailDataUrl = fabricCanvasRef.current.toDataURL({
      format: 'png',
      quality: 0.8,
      multiplier: 0.3
    })

    await documentService.updateDocument(documentId, {
      content: {
        ...document.content,
        canvasData: canvasData,
        thumbnail: thumbnailDataUrl,
      },
    })

    setLastSaved(new Date())
  } catch (error) {
    console.error("Error saving canvas:", error)
  } finally {
    setIsSaving(false)
  }
}