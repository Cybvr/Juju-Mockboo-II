// Modified DocumentGallery component to handle canvas thumbnails:
export function DocumentGallery({
  title = "Recent",
  emptyStateMessage = "No documents found. Start creating!"
}: DocumentGalleryProps) {
  const [documents, setDocuments] = useState<Document[]>([])
  const [flattenedDocuments, setFlattenedDocuments] = useState<FlattenedDocument[]>([])
  const [loading, setLoading] = useState(true)
  // ... other state

  useEffect(() => {
    const loadUserDocuments = async () => {
      if (!user) {
        setLoading(false)
        return
      }
      try {
        setLoading(true)
        const userDocs = await documentService.getUserRecentDocuments(user.uid, 100)
        setDocuments(userDocs)
        
        // Generate flattened documents with canvas thumbnails
        const flattened = await Promise.all(
          userDocs.map(async (doc) => {
            let mediaUrl = doc.content?.thumbnail || '/placeholder.svg';
            
            // Generate thumbnail for canvas documents
            if (doc.type === 'canvas' && doc.content?.canvasData) {
              try {
                mediaUrl = await generateCanvasThumbnail(doc.content.canvasData);
              } catch (error) {
                console.error('Failed to generate canvas thumbnail:', error);
              }
            }
            
            return {
              id: doc.id,
              originalDocId: doc.id,
              title: doc.title,
              type: doc.type,
              mediaUrl,
              mediaType: 'image' as const,
              updatedAt: doc.updatedAt,
              likedBy: doc.likedBy,
              likesCount: doc.likesCount,
              originalDoc: doc
            };
          })
        )
        
        setFlattenedDocuments(flattened)
      } catch (error) {
        console.error("Failed to load documents:", error)
        toast.error("Failed to load your documents")
      } finally {
        setLoading(false)
      }
    }
    loadUserDocuments()
  }, [user])

  // Rest of component remains the same, using flattenedDocuments state instead of computed value
}

// Add to your canvas operations hook:
export const useCanvasOperations = (fabricCanvasRef, documentId, document, canvasState) => {
  // ... existing operations

  const saveThumbnail = useCallback(async () => {
    if (!fabricCanvasRef.current) return;
    
    try {
      const thumbnailDataUrl = fabricCanvasRef.current.toDataURL({
        format: 'png',
        quality: 0.8,
        multiplier: 0.5 // Generate smaller thumbnail
      });
      
      await documentService.updateDocument(documentId, {
        'content.thumbnail': thumbnailDataUrl
      });
    } catch (error) {
      console.error('Error saving thumbnail:', error);
    }
  }, [fabricCanvasRef, documentId]);

  const handleCanvasChange = useCallback(async () => {
    if (!fabricCanvasRef.current || !document) return;

    canvasState.setHasUnsavedChanges(true);
    
    // Save thumbnail when canvas changes
    await saveThumbnail();
    
    // ... rest of existing logic
  }, [fabricCanvasRef, document, saveThumbnail]);

  return {
    // ... other operations
    saveThumbnail
  };
};// Add this utility function to generate canvas thumbnails
export const generateCanvasThumbnail = async (canvasData: any, width: number = 300, height: number = 200): Promise<string> => {
  return new Promise(async (resolve) => {
    try {
      // Import fabric dynamically since it's client-side only
      const { fabric } = await import('fabric');
      
      // Create temporary canvas for thumbnail generation
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = width;
      tempCanvas.height = height;
      
      const fabricCanvas = new fabric.Canvas(tempCanvas, {
        width,
        height,
        backgroundColor: '#ffffff'
      });

      // Load the canvas data
      fabricCanvas.loadFromJSON(canvasData, () => {
        // Fit content to thumbnail size
        const objects = fabricCanvas.getObjects();
        if (objects.length > 0) {
          const group = new fabric.Group(objects);
          const bounds = group.getBoundingRect();
          
          // Calculate scale to fit content
          const scaleX = (width * 0.9) / bounds.width;
          const scaleY = (height * 0.9) / bounds.height;
          const scale = Math.min(scaleX, scaleY, 1);
          
          // Center and scale the content
          fabricCanvas.setViewportTransform([
            scale, 0, 0, scale,
            (width - bounds.width * scale) / 2 - bounds.left * scale,
            (height - bounds.height * scale) / 2 - bounds.top * scale
          ]);
        }
        
        // Generate thumbnail
        const thumbnailDataUrl = fabricCanvas.toDataURL({
          format: 'png',
          quality: 0.8,
          multiplier: 1
        });
        
        // Cleanup
        fabricCanvas.dispose();
        
        resolve(thumbnailDataUrl);
      });
    } catch (error) {
      console.error('Error generating canvas thumbnail:', error);
      resolve('/placeholder.svg'); // Fallback
    }
  });
};

// Modified DocumentGallery component to handle canvas thumbnails:
export function DocumentGallery({
  title = "Recent",
  emptyStateMessage = "No documents found. Start creating!"
}: DocumentGalleryProps) {
  const [documents, setDocuments] = useState<Document[]>([])
  const [flattenedDocuments, setFlattenedDocuments] = useState<FlattenedDocument[]>([])
  const [loading, setLoading] = useState(true)
  // ... other state

  useEffect(() => {
    const loadUserDocuments = async () => {
      if (!user) {
        setLoading(false)
        return
      }
      try {
        setLoading(true)
        const userDocs = await documentService.getUserRecentDocuments(user.uid, 100)
        setDocuments(userDocs)
        
        // Generate flattened documents with canvas thumbnails
        const flattened = await Promise.all(
          userDocs.map(async (doc) => {
            let mediaUrl = doc.content?.thumbnail || '/placeholder.svg';
            
            // Generate thumbnail for canvas documents
            if (doc.type === 'canvas' && doc.content?.canvasData) {
              try {
                mediaUrl = await generateCanvasThumbnail(doc.content.canvasData);
              } catch (error) {
                console.error('Failed to generate canvas thumbnail:', error);
              }
            }
            
            return {
              id: doc.id,
              originalDocId: doc.id,
              title: doc.title,
              type: doc.type,
              mediaUrl,
              mediaType: 'image' as const,
              updatedAt: doc.updatedAt,
              likedBy: doc.likedBy,
              likesCount: doc.likesCount,
              originalDoc: doc
            };
          })
        )
        
        setFlattenedDocuments(flattened)
      } catch (error) {
        console.error("Failed to load documents:", error)
        toast.error("Failed to load your documents")
      } finally {
        setLoading(false)
      }
    }
    loadUserDocuments()
  }, [user])

  // Rest of component remains the same, using flattenedDocuments state instead of computed value
}